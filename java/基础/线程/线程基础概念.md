# Java 线程基础



## volatile

### 初步认识volatile

下面这段代码，演示了一个使用 volatile 以及没使用 volatile 这个关键字，对于变量更新的影响

```java
public class VolatileDemo {
    public /*volatile*/ static boolean is_stop = false;

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (!is_stop) {
            }
        });
        thread.start();
        System.out.println("begin start thread");
        thread.sleep(1000);
        is_stop = true;
    }
}
```



### volatile 的作用

volatile 可以使得在多处理器环境下保证了共享变量的可见性，那么到底什么是可见性呢？

可见性：在单线程的环境下，如果向一个变量先写入一个值，然后在没有写干涉的情况下读取这个变量的值，那这个时候读取到的这个变量的值应该是之前写入的那个值。这本来是一个很正常的事情。但是在多线程环境下，读和写发生在不同的线程中的时候，可能会出现，读线程不能及时的读取到其它线程写入的最新值。

为了实现跨线程写入的内存可见性，必须使用到一些机制来实现。而 volatile 就是这样一种机制。

**volatile 关键字是如何保证可见性的？**

使用hsdis-amd64.dll 查看前面演示的这段代码的汇编指令。

在运行的代码中，设置jvm参数如下：

```
-server 
-Xcomp 
-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly 
-XX:CompileCommand=compileonly,*TestDemo.*
```

在修改带有 volatile 修饰的成员变量时，会多一个lock指令。lock是一种控制指令，在多处理器环境下，lock 汇编指令可以基础总线锁或者缓存锁的机制来达到可见性的一个效果。



## JMM

### JMM 定义

JMM 全程是java memory model 。（java内存模型）

导致可见性问题的根本原因是缓存以及重排序。而JMM实际上就是提供了合理的禁用缓存以及禁止重排序的方法。所以它最核心的价值在于解决可见性和有序性。

JMM 属于语言级别的抽象内存模型，可以简单理解为对硬件模型的抽象，它定义了共享内存中多线程程序读写操作的行为规范：在虚拟机中把共享变量存储到内存以及从内存中取出共享变量的底层实现细节。

通过这些规则来规范对内存的读写操作从而保证指令的正确性，它解决了CPU多级缓存、处理器优化、指令重排序导致的内存访问问题，保证了并发场景下的可见性。

需要注意的是，JMM 并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序，也就是说在JMM中，也会存在缓存一致性问题和指令重排序问题。只是 JMM 把底层的问题抽象到 JMM 层面，在基于CPU层面提供的内存屏障指令，以及限制编译器的重排序来解决并发问题。

JMM 抽象模型分为主内存、工作内存；

+ 主内存是所有线程共享的，一般是实例对象、静态字段、数组对象等存储在堆内存中的变量。

+ 工作内存是每个线程独占的，线程对变量得所有操作都必须在工作内存中进行，不能直接读写主内存中的变量，线程之间的共享变量值的传递都是基于主内存来完成的。

Java 内存模型底层实现可以简单的认为：通过内存屏障（memory barrier）禁止重排序，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的CPU指令。对于编译器而言，内存屏障将会导致缓存的刷新操作。比如，对于 volatile ，编辑器将在 volatile 字段的读写操作前后个插入一些内存屏障。



### JMM是如何解决可见性有序性问题的



简单来说， JMM 提供了一些禁用缓存以及禁止重排序的方法，来解决可见性和有序性问题。

例如：volatile、synchronized、final



### JMM是如何解决顺序一致性问题

#### 重排序问题

为了提高程序的执行性能，编译器和处理器都会对指令做重排序。所谓的重排序就是指执行的指令顺序。

编译器的重排序指的是程序编写的指令在编译之后，指令可能会产生重排序来优化程序的执行性能。

编译器的重排序，JMM 提供了禁止特定类型的编译器重排序。 

处理器重排序，JMM 会要求编译器生成指令时，会插入内存屏障来禁止处理器重排序。

#### JMM的内存屏障

为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障来禁止特定类型的处理器的重排序



## HappenBefore

它的意思表示的是前一个操作的结果对于后续操作是可见的，所以它是一种表达多个线程之间对于内存的可见性。

所以我们可以认为在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作必须要存在happens-before 关系。这两个操作可以使同一个线程，也可以是不同的线程。

### JMM 中有哪些方法建立 happen-before 规则

#### 程序顺序规则

1. 一个线程中的每个操作，happens-before 于该线程中任意后续操作；可以简单认为是as-if-serial。单个线程中的代码顺序不管怎么变，对于结果来说是不变的顺序规则表示

