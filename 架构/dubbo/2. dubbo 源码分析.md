# spi 机制演示

## java spi 机制

demo：

```java
public interface Robot {
    void sayHello();
}
```

```java
public class ARobot implements Robot {
    @Override
    public void sayHello() {
        System.out.println("hello a robot");
    }
}

public class BRobot implements Robot {
    @Override
    public void sayHello() {
        System.out.println("hello b robot");
    }
}
```

​		在`resources`目录下新建`META-INF/services`目录，并新建`Robot`类名全路径文件(com.study.Robot)，在该文件内增加如下内容

```
com.study.ARobot
com.study.BRobot
```



测试

```java
public static void main(String[] args) {
    ServiceLoader<Robot> serviceLoader = ServiceLoader.load(Robot.class);
    serviceLoader.forEach(Robot::sayHello);
}
```





## dubbo spi 机制



​		先引入dubbo的相关jar包，在上述代码中的`Robot`代码中新增类注解`@SPI`，并在在`resources`目录下新建`META-INF/dubbo`目录，并新建`Robot`类名全路径文件(com.study.Robot)，在该文件内增加如下内容

```
a=com.example.dubbo.demo.spi.ARobot
b=com.example.dubbo.demo.spi.BRobot
```



测试

```java
 public static void main(String[] args) {

     ExtensionLoader<Robot> extensionLoader = ExtensionLoader.getExtensionLoader(Robot.class);
     Robot a = extensionLoader.getExtension("a");
     a.sayHello();
     Robot b = extensionLoader.getExtension("b");
     b.sayHello();
 }
```





# dubbo 2.7.2 spi 机制原理分析

[dubbo 官网分析](http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html)



# dubbo 2.7.2 自适应拓展机制



[自适应拓展机制](http://dubbo.apache.org/zh-cn/docs/source_code_guide/adaptive-extension.html)



# dubbo 2.7.2 服务发布源码分析

在对dubbo的集成使用，如果要实现服务的发布注册，需要做如下几步：

1. 解析配置文件
2. 服务注册
3. 启动netty服务实现远程监听



​		dubbo 是通过spring的对外提供的config配置来集成，spring启动会自动扫描`dubbo-config-spring`模块下`META-INF/spring.handlers` 文件。

```java
public class DubboNamespaceHandler extends NamespaceHandlerSupport {

    static {
        Version.checkDuplicate(DubboNamespaceHandler.class);
    }

    @Override
    public void init() {
        // 省略
        // 服务发布
        registerBeanDefinitionParser("service", new DubboBeanDefinitionParser(ServiceBean.class, true));
    }
}
```



DubboBeanDefinitionParser： 类主要是解析配置文件中的`<dubbo:service>`标签相关的代码

ServiceBean：是服务发布相关类



## ServiceBean



```java
public class ServiceBean<T> extends ServiceConfig<T> implements InitializingBean, DisposableBean,
ApplicationContextAware, ApplicationListener<ContextRefreshedEvent>, BeanNameAware,
ApplicationEventPublisherAware {
    // 省略...
}
```

​		ServiceBean 主要实现了InitializingBean、DisposableBean、ApplicationContextAware、ApplicationListener、BeanNameAware、ApplicationEventPublisherAware



- InitializingBean：为bean提供了初始化方法，凡是实现该接口的类，在初始化的时候会执行`afterPropertiesSet`
- DisposableBean: bean被销毁的时候，spring会自动执行destory方法
- ApplicationContextAware：当容器初始化的时候，会自动的酱ApplicationContext注入进来
- ApplicationListener：事件监听，spring容器启动后会发一个事件通知。
- BeanNameAware：获得自身初始化时，本身的bean的id属性
- ApplicationEventPublisherAware：异步事件发送器



**ServiceBean** 主要关注的是两个方法，分别是

1. 在初始化bena的时候会执行**afterPropertiesSet**
2. 在spring容器启动后会发一个事件通知 **onApplicationEvent**



### afterPropertiesSet

​		查看源码发现这个方法里面，就是把 dubbo 中配置的 application、registry、service、protocol 等信息，加载到对应的 config 实体中，便于后续的使用

### onApplicationEvent



```java
public void onApplicationEvent(ContextRefreshedEvent event) {
    // 是否已导出 && 是不是已被取消导出
    if (!isExported() && !isUnexported()) {
        if (logger.isInfoEnabled()) {
            logger.info("The service ready on spring started. service: " + getInterface());
        }
        export(); //导出、发布
    }
}

public void export() {
    // 导出
    super.export();
    // Publish ServiceBeanExportedEvent
    publishExportEvent();
}
```



**ServiceConfig**

```java
public synchronized void export() {
    checkAndUpdateSubConfigs(); //检查或这个更新配置
    if (!shouldExport()) { //当前服务是否要发布
        return;
    }
    if (shouldDelay()) {//是否延迟
        delayExportExecutor.schedule(this::doExport, getDelay(), TimeUnit.MILLISECONDS);
    } else {
        doExport(); // 处理发布逻辑
    }
}

```



#### ServiceConfig.doExport()

```java
protected synchronized void doExport() {
    if (unexported) {
        throw new IllegalStateException("The service " + interfaceClass.getName() + " has already unexported!");
    }
    if (exported) {
        return;
    }
    exported = true;
    //path=org.apache.dubbo.config.spring.api.DemoService
    if (StringUtils.isEmpty(path)) { //path=interfaceName
        path = interfaceName;
    }
    doExportUrls();
}
```



#### ServiceConfig.doExportUrls()

```java
private void doExportUrls() {
    //加载注册中心，并且声称URL地址
    //URL(来驱动流程的执行)->[  registry://192.168.13.106:2181/org.apache.dubbo.registry.RegsitryService/....]
    List<URL> registryURLs = loadRegistries(true);
    for (ProtocolConfig protocolConfig : protocols) {
        //iterface , version ,group组成的key
        String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -> p + "/" + path).orElse(path), group, version);
        //存储服务发布的元数据
        ProviderModel providerModel = new ProviderModel(pathKey, ref, interfaceClass);
        ApplicationModel.initProviderModel(pathKey, providerModel);
        doExportUrlsFor1Protocol(protocolConfig, registryURLs);
    }
}
```



#### ServiceConfig.doExportUrlsFor1Protocol()

```java
private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {
    //name =dubbo  -><dubbo:protocol  name="dubbo"/>
    String name = protocolConfig.getName(); 
    if (StringUtils.isEmpty(name)) {
        name = DUBBO;
    }

    Map<String, String> map = new HashMap<String, String>();
    map.put(SIDE_KEY, PROVIDER_SIDE);

    appendRuntimeParameters(map);
    appendParameters(map, metrics);
    appendParameters(map, application);
    appendParameters(map, module);
    // remove 'default.' prefix for configs from ProviderConfig
    // appendParameters(map, provider, Constants.DEFAULT_KEY);
    appendParameters(map, provider);
    appendParameters(map, protocolConfig);
    appendParameters(map, this);
    
    if (CollectionUtils.isNotEmpty(methods)) {
        // 代码太长了，省略 ...
        // 主要处理下述标签
        //<dubbo:service>
    	//    <dubbo:method>
    	// </dubbo:service>
    }

    if (ProtocolUtils.isGeneric(generic)) {
        map.put(GENERIC_KEY, generic);
        map.put(METHODS_KEY, ANY_VALUE);
    } else {
        String revision = Version.getVersion(interfaceClass, version);
        if (revision != null && revision.length() > 0) {
            map.put(REVISION_KEY, revision);
        }

        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();
        if (methods.length == 0) {
            logger.warn("No method found in service interface " + interfaceClass.getName());
            map.put(METHODS_KEY, ANY_VALUE);
        } else {
            map.put(METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), ","));
        }
    }
    if (!ConfigUtils.isEmpty(token)) {
        if (ConfigUtils.isDefault(token)) {
            map.put(TOKEN_KEY, UUID.randomUUID().toString());
        } else {
            map.put(TOKEN_KEY, token);
        }
    }
    // export service
    //主机绑定
    String host = this.findConfigedHosts(protocolConfig, registryURLs, map);
    Integer port = this.findConfigedPorts(protocolConfig, name, map);
    //dubbo://192.168.1.23:20813/org.apache.dubbo.config.spring.api.DemoService
    URL url = new URL(name, host, port, getContextPath(protocolConfig).map(p -> p + "/" + path).orElse(path), map);
    // 动态配置修改
    if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
        .hasExtension(url.getProtocol())) {
        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
            .getExtension(url.getProtocol()).getConfigurator(url).configure(url);
    }

    //url已经组装好了，接下来只需要发布。（context->url）
    //scope 选择服务发布的范围（local/remote）
    //同一个jvm里面调用，没必要走远程通信； injvm://ip:port..
    //remote :  dubbo://ip:port
    //默认情况下，如果是配置remote（registry），默认发布远程和本地
    String scope = url.getParameter(SCOPE_KEY);
    // don't export when none is configured
    if (!SCOPE_NONE.equalsIgnoreCase(scope)) {

        // 如果是本地发布，则直接调用exportLocal
        if (!SCOPE_REMOTE.equalsIgnoreCase(scope)) {
            exportLocal(url);  
        }
        // export to remote if the config is not local (export to local only when config is local)
        if (!SCOPE_LOCAL.equalsIgnoreCase(scope)) {
            if (!isOnlyInJvm() && logger.isInfoEnabled()) {
                logger.info("Export dubbo service " + interfaceClass.getName() + " to url " + url);
            }
            if (CollectionUtils.isNotEmpty(registryURLs)) {
                //registryURL: registry://ip:port...
                for (URL registryURL : registryURLs) { 
                    //if protocol is only injvm ,not register
                    if (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {
                        continue;
                    }
                    url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));
                    URL monitorUrl = loadMonitor(registryURL);
                    if (monitorUrl != null) {
                        url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());
                    }
                    if (logger.isInfoEnabled()) {
                        logger.info("Register dubbo service " + interfaceClass.getName() + " url " + url + " to registry " + registryURL);
                    }

                    // For providers, this is used to enable custom proxy to generate invoker
                    String proxy = url.getParameter(PROXY_KEY);
                    if (StringUtils.isNotEmpty(proxy)) {
                        registryURL = registryURL.addParameter(PROXY_KEY, proxy);
                    }
                    // invoker -> 代理类
                    Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));
                    //MetaData元数据的委托
                    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
                    // wrapperInvoker : registry:///
                    // Protocol$Adaptive(->做适配spi)
                    // RegistryProtocol-> getExtension("registry")
                    Exporter<?> exporter = protocol.export(wrapperInvoker);
                    exporters.add(exporter);
                }
            } else {
                Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);
                DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);

                Exporter<?> exporter = protocol.export(wrapperInvoker);
                exporters.add(exporter);
            }
           
            MetadataReportService metadataReportService = null;
            if ((metadataReportService = getMetadataReportService()) != null) {
                metadataReportService.publishProvider(url);
            }
        }
    }
    this.urls.add(url);
}
```



#### ServiceConfig.findConfigedHosts()

```java
private String findConfigedHosts(ProtocolConfig protocolConfig, List<URL> registryURLs, Map<String, String> map) {
    boolean anyhost = false;
    //<dubbo:protocol   host=""/>
    // 配置文件中找主机ip地址
    String hostToBind = getValueFromConfig(protocolConfig, DUBBO_IP_TO_BIND);
    if (hostToBind != null && hostToBind.length() > 0 && isInvalidLocalHost(hostToBind)) {
        throw new IllegalArgumentException("Specified invalid bind ip from property:" + DUBBO_IP_TO_BIND + ", value:" + hostToBind);
    }

    // if bind ip is not found in environment, keep looking up
    if (StringUtils.isEmpty(hostToBind)) {
        hostToBind = protocolConfig.getHost();
        if (provider != null && StringUtils.isEmpty(hostToBind)) {
            hostToBind = provider.getHost();
        }
        if (isInvalidLocalHost(hostToBind)) {
            anyhost = true;
            try {
                // 获取/etc/hosts中配置的网络地址
                hostToBind = InetAddress.getLocalHost().getHostAddress();
            } catch (UnknownHostException e) {
                logger.warn(e.getMessage(), e);
            }
            if (isInvalidLocalHost(hostToBind)) {
                if (CollectionUtils.isNotEmpty(registryURLs)) {
                    // 通过向注册中心发送一个请求，在请求中获取本机地址
                    for (URL registryURL : registryURLs) {
                        if (MULTICAST.equalsIgnoreCase(registryURL.getParameter("registry"))) {
                            continue;
                        }
                        try (Socket socket = new Socket()) {
                            SocketAddress addr = new InetSocketAddress(registryURL.getHost(), registryURL.getPort());
                            socket.connect(addr, 1000);
                            hostToBind = socket.getLocalAddress().getHostAddress();
                            break;
                        } catch (Exception e) {
                            logger.warn(e.getMessage(), e);
                        }
                    }
                }
                if (isInvalidLocalHost(hostToBind)) {
                    hostToBind = getLocalHost();
                }
            }
        }
    }

    map.put(Constants.BIND_IP_KEY, hostToBind);

    // registry ip is not used for bind ip by default
    String hostToRegistry = getValueFromConfig(protocolConfig, DUBBO_IP_TO_REGISTRY);
    if (hostToRegistry != null && hostToRegistry.length() > 0 && isInvalidLocalHost(hostToRegistry)) {
        throw new IllegalArgumentException("Specified invalid registry ip from property:" + DUBBO_IP_TO_REGISTRY + ", value:" + hostToRegistry);
    } else if (StringUtils.isEmpty(hostToRegistry)) {
        // bind ip is used as registry ip by default
        hostToRegistry = hostToBind;
    }

    map.put(ANYHOST_KEY, String.valueOf(anyhost));

    return hostToRegistry;
}
```



#### RegistryProtocol.export()

```java
//实现服务的注册和发布
@Override
public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {
    // registryUrl -> zookeeper://ip:port
    URL registryUrl = getRegistryUrl(originInvoker);
    // providerUrl -> dubbo:// ip:port
    URL providerUrl = getProviderUrl(originInvoker);

    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);
    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);
    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);

    providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);

    /***********************************/
    //doLocalExport 本质就是去启动一个netty服务
    final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker, providerUrl);

    // 把dubbo:// url注册到zk上
    final Registry registry = getRegistry(originInvoker);
    final URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);
    ProviderInvokerWrapper<T> providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);
    //to judge if we need to delay publish
    boolean register = registeredProviderUrl.getParameter("register", true);
    if (register) {
        // 注册到注册中心
        register(registryUrl, registeredProviderUrl);
        providerInvokerWrapper.setReg(true);
    }

    // Deprecated! Subscribe to override rules in 2.6.x or before.
    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);

    exporter.setRegisterUrl(registeredProviderUrl);
    exporter.setSubscribeUrl(overrideSubscribeUrl);
    //Ensure that a new exporter instance is returned every time export
    return new DestroyableExporter<>(exporter);
}
```



#### RegistryProtocol.doLocalExport()



```java
private <T> ExporterChangeableWrapper<T> doLocalExport(final Invoker<T> originInvoker, URL providerUrl) {
    String key = getCacheKey(originInvoker);
    //bounds -chm  ->computeIfAbsent  if(map.get(key)==null){map.put()}
    return (ExporterChangeableWrapper<T>) bounds.computeIfAbsent(key, s -> {
        //orginInvoker->   InvokerDelegate(DelegateProviderMetaDataInvoker(invoker))
        Invoker<?> invokerDelegate = new InvokerDelegate<>(originInvoker, providerUrl);
        //protocol.export -> DubboProtocol.export(本质上就是 暴露一个 20880的端口）
        //protocol- >Protocol$Apaptive ->QosProtocolWrapper(ProtocolListenerWrapper(ProtocolFilterWrapper(DubboProtocol(invoker)))) 包装器调用，最后调用到 DubboProtocol
        return new ExporterChangeableWrapper<>((Exporter<T>) protocol.export(invokerDelegate), originInvoker);
    });
}
```



#### DubboProtocol.export()



```java
public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
    URL url = invoker.getUrl();

    // export service.
    String key = serviceKey(url);
    DubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);
    exporterMap.put(key, exporter);

    //export an stub service for dispatching event
    Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);
    Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, false);
    if (isStubSupportEvent && !isCallbackservice) {
        String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);
        if (stubServiceMethods == null || stubServiceMethods.length() == 0) {
            if (logger.isWarnEnabled()) {
                logger.warn(new IllegalStateException("consumer [" + url.getParameter(INTERFACE_KEY) +
                                                      "], has set stubproxy support event ,but no stub methods founded."));
            }

        } else {
            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);
        }
    }

    openServer(url); //openServer（url） 开启一个服务 ，暴露20880端口
    optimizeSerialization(url);  //优化序列化

    return exporter;
}
```



#### DubboProtocol.openServer()



```java
private void openServer(URL url) {
    // find server.
    String key = url.getAddress();
    //client can export a service which's only for server to invoke
    boolean isServer = url.getParameter(IS_SERVER_KEY, true);
    if (isServer) {
        //缓存， 一个key只对应一个exchangeServer
        ExchangeServer server = serverMap.get(key);
        if (server == null) {
            synchronized (this) {
                server = serverMap.get(key);
                if (server == null) {
                    // 创建服务
                    serverMap.put(key, createServer(url));
                }
            }
        } else {
            // server supports reset, use together with override
            server.reset(url);
        }
    }
}

```



#### DubboProtocol.createServer()



```java
private ExchangeServer createServer(URL url) {
    url = URLBuilder.from(url)
        // send readonly event when server closes, it's enabled by default
        .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())
        // enable heartbeat by default
        .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))
        .addParameter(CODEC_KEY, DubboCodec.NAME)
        .build();
    //获得当前应该采用什么样的方式来发布服务， netty3, netty4, mina , grizzy,
    String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);

    if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {
        throw new RpcException("Unsupported server type: " + str + ", url: " + url);
    }

    ExchangeServer server;
    try {
        server = Exchangers.bind(url, requestHandler);
    } catch (RemotingException e) {
        throw new RpcException("Fail to start server(url: " + url + ") " + e.getMessage(), e);
    }

    str = url.getParameter(CLIENT_KEY);
    if (str != null && str.length() > 0) {
        Set<String> supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();
        if (!supportedTypes.contains(str)) {
            throw new RpcException("Unsupported client type: " + str);
        }
    }

    return server;
}
```



#### AbstractRegistryFactory.getRegistry()



```java
public Registry getRegistry(URL url) {
    url = URLBuilder.from(url)
        .setPath(RegistryService.class.getName())
        .addParameter(INTERFACE_KEY, RegistryService.class.getName())
        .removeParameters(EXPORT_KEY, REFER_KEY)
        .build();
    String key = url.toServiceStringWithoutResolving();
    // Lock the registry access process to ensure a single instance of the registry
    LOCK.lock();
    try {
        Registry registry = REGISTRIES.get(key);
        if (registry != null) {
            return registry;
        }
        //create registry by spi/ioc
        // 创建注册中心
        registry = createRegistry(url);
        if (registry == null) {
            throw new IllegalStateException("Can not create registry " + url);
        }
        REGISTRIES.put(key, registry);
        return registry;
    } finally {
        // Release the lock
        LOCK.unlock();
    }
}
```





#### AbstractRegistryFactory.createRegistry()

```java
protected Registry createRegistry(URL url) {
    // 通过生成的RegistryFactory$Adaptive 调用
    // 根据协议zookeeper:// 
    // 调用ZookeeperRegistryFactory 类中方法
    return createRegistry(new com.alibaba.dubbo.common.URL(url));
}
```



#### ZookeeperRegistryFactory.createRegistry()

```java
public Registry createRegistry(URL url) {
    return new ZookeeperRegistry(url, zookeeperTransporter);
}
```



#### ZookeeperRegistry构造

```java
public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) {
    super(url);
    if (url.isAnyHost()) {
        throw new IllegalStateException("registry address == null");
    }
    String group = url.getParameter(GROUP_KEY, DEFAULT_ROOT);
    if (!group.startsWith(PATH_SEPARATOR)) {
        group = PATH_SEPARATOR + group;
    }
    this.root = group;
    // 启动一个zookeeper 连接 
    // 后续启动就分析了，就是创建zk节点信息、监听等等
    zkClient = zookeeperTransporter.connect(url);
    zkClient.addStateListener(state -> {
        if (state == StateListener.RECONNECTED) {
            try {
                recover();
            } catch (Exception e) {
                logger.error(e.getMessage(), e);
            }
        }
    });
}
```



// TODO  连接zk

ZookeeperTransporter

