# spi 机制演示

## java spi 机制

demo：

```java
public interface Robot {
    void sayHello();
}
```

```java
public class ARobot implements Robot {
    @Override
    public void sayHello() {
        System.out.println("hello a robot");
    }
}

public class BRobot implements Robot {
    @Override
    public void sayHello() {
        System.out.println("hello b robot");
    }
}
```

​		在`resources`目录下新建`META-INF/services`目录，并新建`Robot`类名全路径文件(com.study.Robot)，在该文件内增加如下内容

```
com.study.ARobot
com.study.BRobot
```



测试

```java
public static void main(String[] args) {
    ServiceLoader<Robot> serviceLoader = ServiceLoader.load(Robot.class);
    serviceLoader.forEach(Robot::sayHello);
}
```





## dubbo spi 机制



​		先引入dubbo的相关jar包，在上述代码中的`Robot`代码中新增类注解`@SPI`，并在在`resources`目录下新建`META-INF/dubbo`目录，并新建`Robot`类名全路径文件(com.study.Robot)，在该文件内增加如下内容

```
a=com.example.dubbo.demo.spi.ARobot
b=com.example.dubbo.demo.spi.BRobot
```



测试

```java
 public static void main(String[] args) {

     ExtensionLoader<Robot> extensionLoader = ExtensionLoader.getExtensionLoader(Robot.class);
     Robot a = extensionLoader.getExtension("a");
     a.sayHello();
     Robot b = extensionLoader.getExtension("b");
     b.sayHello();
 }
```





# dubbo 2.7.2 spi 机制原理分析

[dubbo 官网分析](http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html)



# dubbo 2.7.2 自适应拓展机制



[自适应拓展机制](http://dubbo.apache.org/zh-cn/docs/source_code_guide/adaptive-extension.html)



# dubbo 2.7.2 服务发布源码分析

在对dubbo的集成使用，如果要实现服务的发布注册，需要做如下几步：

1. 解析配置文件
2. 服务注册
3. 启动netty服务实现远程监听



​		dubbo 是通过spring的对外提供的config配置来集成，spring启动会自动扫描`dubbo-config-spring`模块下`META-INF/spring.handlers` 文件。

```java
public class DubboNamespaceHandler extends NamespaceHandlerSupport {

    static {
        Version.checkDuplicate(DubboNamespaceHandler.class);
    }

    @Override
    public void init() {
        // 省略
        // 服务发布
        registerBeanDefinitionParser("service", new DubboBeanDefinitionParser(ServiceBean.class, true));
    }
}
```



DubboBeanDefinitionParser： 类主要是解析配置文件中的`<dubbo:service>`标签相关的代码

ServiceBean：是服务发布相关类



## ServiceBean



```java
public class ServiceBean<T> extends ServiceConfig<T> implements InitializingBean, DisposableBean,
ApplicationContextAware, ApplicationListener<ContextRefreshedEvent>, BeanNameAware,
ApplicationEventPublisherAware {
    // 省略...
}
```

​		ServiceBean 主要实现了InitializingBean、DisposableBean、ApplicationContextAware、ApplicationListener、BeanNameAware、ApplicationEventPublisherAware



- InitializingBean：为bean提供了初始化方法，凡是实现该接口的类，在初始化的时候会执行`afterPropertiesSet`
- DisposableBean: bean被销毁的时候，spring会自动执行destory方法
- ApplicationContextAware：当容器初始化的时候，会自动的酱ApplicationContext注入进来
- ApplicationListener：事件监听，spring容器启动后会发一个事件通知。
- BeanNameAware：获得自身初始化时，本身的bean的id属性
- ApplicationEventPublisherAware：异步事件发送器



**ServiceBean** 主要关注的是两个方法，分别是

1. 在初始化bena的时候会执行**afterPropertiesSet**
2. 在spring容器启动后会发一个事件通知 **onApplicationEvent**



### afterPropertiesSet

​		查看源码发现这个方法里面，就是把 dubbo 中配置的 application、registry、service、protocol 等信息，加载到对应的 config 实体中，便于后续的使用

### onApplicationEvent



```java
public void onApplicationEvent(ContextRefreshedEvent event) {
    // 是否已导出 && 是不是已被取消导出
    if (!isExported() && !isUnexported()) {
        if (logger.isInfoEnabled()) {
            logger.info("The service ready on spring started. service: " + getInterface());
        }
        export(); //导出、发布
    }
}

public void export() {
    // 导出
    super.export();
    // Publish ServiceBeanExportedEvent
    publishExportEvent();
}
```



**ServiceConfig**

```java
public synchronized void export() {
    checkAndUpdateSubConfigs(); //检查或这个更新配置
    if (!shouldExport()) { //当前服务是否要发布
        return;
    }
    if (shouldDelay()) {//是否延迟
        delayExportExecutor.schedule(this::doExport, getDelay(), TimeUnit.MILLISECONDS);
    } else {
        doExport(); // 处理发布逻辑
    }
}

```



#### ServiceConfig.doExport()

```java
protected synchronized void doExport() {
    if (unexported) {
        throw new IllegalStateException("The service " + interfaceClass.getName() + " has already unexported!");
    }
    if (exported) {
        return;
    }
    exported = true;
    //path=org.apache.dubbo.config.spring.api.DemoService
    if (StringUtils.isEmpty(path)) { //path=interfaceName
        path = interfaceName;
    }
    doExportUrls();
}
```



#### ServiceConfig.doExportUrls()

```java
private void doExportUrls() {
    //加载注册中心，并且声称URL地址
    //URL(来驱动流程的执行)->[  registry://192.168.13.106:2181/org.apache.dubbo.registry.RegsitryService/....]
    List<URL> registryURLs = loadRegistries(true);
    for (ProtocolConfig protocolConfig : protocols) {
        //iterface , version ,group组成的key
        String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -> p + "/" + path).orElse(path), group, version);
        //存储服务发布的元数据
        ProviderModel providerModel = new ProviderModel(pathKey, ref, interfaceClass);
        ApplicationModel.initProviderModel(pathKey, providerModel);
        doExportUrlsFor1Protocol(protocolConfig, registryURLs);
    }
}
```



#### ServiceConfig.doExportUrlsFor1Protocol()

```java
private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {
    //name =dubbo  -><dubbo:protocol  name="dubbo"/>
    String name = protocolConfig.getName(); 
    if (StringUtils.isEmpty(name)) {
        name = DUBBO;
    }

    Map<String, String> map = new HashMap<String, String>();
    map.put(SIDE_KEY, PROVIDER_SIDE);

    appendRuntimeParameters(map);
    appendParameters(map, metrics);
    appendParameters(map, application);
    appendParameters(map, module);
    // remove 'default.' prefix for configs from ProviderConfig
    // appendParameters(map, provider, Constants.DEFAULT_KEY);
    appendParameters(map, provider);
    appendParameters(map, protocolConfig);
    appendParameters(map, this);
    
    if (CollectionUtils.isNotEmpty(methods)) {
        // 代码太长了，省略 ...
        // 主要处理下述标签
        //<dubbo:service>
    	//    <dubbo:method>
    	// </dubbo:service>
    }

    if (ProtocolUtils.isGeneric(generic)) {
        map.put(GENERIC_KEY, generic);
        map.put(METHODS_KEY, ANY_VALUE);
    } else {
        String revision = Version.getVersion(interfaceClass, version);
        if (revision != null && revision.length() > 0) {
            map.put(REVISION_KEY, revision);
        }

        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();
        if (methods.length == 0) {
            logger.warn("No method found in service interface " + interfaceClass.getName());
            map.put(METHODS_KEY, ANY_VALUE);
        } else {
            map.put(METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), ","));
        }
    }
    if (!ConfigUtils.isEmpty(token)) {
        if (ConfigUtils.isDefault(token)) {
            map.put(TOKEN_KEY, UUID.randomUUID().toString());
        } else {
            map.put(TOKEN_KEY, token);
        }
    }
    // export service
    //主机绑定
    String host = this.findConfigedHosts(protocolConfig, registryURLs, map);
    Integer port = this.findConfigedPorts(protocolConfig, name, map);
    //dubbo://192.168.1.23:20813/org.apache.dubbo.config.spring.api.DemoService
    URL url = new URL(name, host, port, getContextPath(protocolConfig).map(p -> p + "/" + path).orElse(path), map);
    // 动态配置修改
    if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
        .hasExtension(url.getProtocol())) {
        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
            .getExtension(url.getProtocol()).getConfigurator(url).configure(url);
    }

    //url已经组装好了，接下来只需要发布。（context->url）
    //scope 选择服务发布的范围（local/remote）
    //同一个jvm里面调用，没必要走远程通信； injvm://ip:port..
    //remote :  dubbo://ip:port
    //默认情况下，如果是配置remote（registry），默认发布远程和本地
    String scope = url.getParameter(SCOPE_KEY);
    // don't export when none is configured
    if (!SCOPE_NONE.equalsIgnoreCase(scope)) {

        // 如果是本地发布，则直接调用exportLocal
        if (!SCOPE_REMOTE.equalsIgnoreCase(scope)) {
            exportLocal(url);  
        }
        // export to remote if the config is not local (export to local only when config is local)
        if (!SCOPE_LOCAL.equalsIgnoreCase(scope)) {
            if (!isOnlyInJvm() && logger.isInfoEnabled()) {
                logger.info("Export dubbo service " + interfaceClass.getName() + " to url " + url);
            }
            if (CollectionUtils.isNotEmpty(registryURLs)) {
                //registryURL: registry://ip:port...
                for (URL registryURL : registryURLs) { 
                    //if protocol is only injvm ,not register
                    if (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {
                        continue;
                    }
                    url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));
                    URL monitorUrl = loadMonitor(registryURL);
                    if (monitorUrl != null) {
                        url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());
                    }
                    if (logger.isInfoEnabled()) {
                        logger.info("Register dubbo service " + interfaceClass.getName() + " url " + url + " to registry " + registryURL);
                    }

                    // For providers, this is used to enable custom proxy to generate invoker
                    String proxy = url.getParameter(PROXY_KEY);
                    if (StringUtils.isNotEmpty(proxy)) {
                        registryURL = registryURL.addParameter(PROXY_KEY, proxy);
                    }
                    // invoker -> 代理类
                    Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));
                    //MetaData元数据的委托
                    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
                    // wrapperInvoker : registry:///
                    // Protocol$Adaptive(->做适配spi)
                    // RegistryProtocol-> getExtension("registry")
                    Exporter<?> exporter = protocol.export(wrapperInvoker);
                    exporters.add(exporter);
                }
            } else {
                Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);
                DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);

                Exporter<?> exporter = protocol.export(wrapperInvoker);
                exporters.add(exporter);
            }
           
            MetadataReportService metadataReportService = null;
            if ((metadataReportService = getMetadataReportService()) != null) {
                metadataReportService.publishProvider(url);
            }
        }
    }
    this.urls.add(url);
}
```



#### ServiceConfig.findConfigedHosts()

```java
private String findConfigedHosts(ProtocolConfig protocolConfig, List<URL> registryURLs, Map<String, String> map) {
    boolean anyhost = false;
    //<dubbo:protocol   host=""/>
    // 配置文件中找主机ip地址
    String hostToBind = getValueFromConfig(protocolConfig, DUBBO_IP_TO_BIND);
    if (hostToBind != null && hostToBind.length() > 0 && isInvalidLocalHost(hostToBind)) {
        throw new IllegalArgumentException("Specified invalid bind ip from property:" + DUBBO_IP_TO_BIND + ", value:" + hostToBind);
    }

    // if bind ip is not found in environment, keep looking up
    if (StringUtils.isEmpty(hostToBind)) {
        hostToBind = protocolConfig.getHost();
        if (provider != null && StringUtils.isEmpty(hostToBind)) {
            hostToBind = provider.getHost();
        }
        if (isInvalidLocalHost(hostToBind)) {
            anyhost = true;
            try {
                // 获取/etc/hosts中配置的网络地址
                hostToBind = InetAddress.getLocalHost().getHostAddress();
            } catch (UnknownHostException e) {
                logger.warn(e.getMessage(), e);
            }
            if (isInvalidLocalHost(hostToBind)) {
                if (CollectionUtils.isNotEmpty(registryURLs)) {
                    // 通过向注册中心发送一个请求，在请求中获取本机地址
                    for (URL registryURL : registryURLs) {
                        if (MULTICAST.equalsIgnoreCase(registryURL.getParameter("registry"))) {
                            continue;
                        }
                        try (Socket socket = new Socket()) {
                            SocketAddress addr = new InetSocketAddress(registryURL.getHost(), registryURL.getPort());
                            socket.connect(addr, 1000);
                            hostToBind = socket.getLocalAddress().getHostAddress();
                            break;
                        } catch (Exception e) {
                            logger.warn(e.getMessage(), e);
                        }
                    }
                }
                if (isInvalidLocalHost(hostToBind)) {
                    hostToBind = getLocalHost();
                }
            }
        }
    }

    map.put(Constants.BIND_IP_KEY, hostToBind);

    // registry ip is not used for bind ip by default
    String hostToRegistry = getValueFromConfig(protocolConfig, DUBBO_IP_TO_REGISTRY);
    if (hostToRegistry != null && hostToRegistry.length() > 0 && isInvalidLocalHost(hostToRegistry)) {
        throw new IllegalArgumentException("Specified invalid registry ip from property:" + DUBBO_IP_TO_REGISTRY + ", value:" + hostToRegistry);
    } else if (StringUtils.isEmpty(hostToRegistry)) {
        // bind ip is used as registry ip by default
        hostToRegistry = hostToBind;
    }

    map.put(ANYHOST_KEY, String.valueOf(anyhost));

    return hostToRegistry;
}
```



#### RegistryProtocol.export()

```java
//实现服务的注册和发布
@Override
public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {
    // registryUrl -> zookeeper://ip:port
    URL registryUrl = getRegistryUrl(originInvoker);
    // providerUrl -> dubbo:// ip:port
    URL providerUrl = getProviderUrl(originInvoker);

    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);
    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);
    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);

    providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);

    /***********************************/
    //doLocalExport 本质就是去启动一个netty服务
    final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker, providerUrl);

    // 把dubbo:// url注册到zk上
    final Registry registry = getRegistry(originInvoker);
    final URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);
    ProviderInvokerWrapper<T> providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);
    //to judge if we need to delay publish
    boolean register = registeredProviderUrl.getParameter("register", true);
    if (register) {
        // 注册到注册中心
        register(registryUrl, registeredProviderUrl);
        providerInvokerWrapper.setReg(true);
    }

    // Deprecated! Subscribe to override rules in 2.6.x or before.
    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);

    exporter.setRegisterUrl(registeredProviderUrl);
    exporter.setSubscribeUrl(overrideSubscribeUrl);
    //Ensure that a new exporter instance is returned every time export
    return new DestroyableExporter<>(exporter);
}
```



#### RegistryProtocol.doLocalExport()



```java
private <T> ExporterChangeableWrapper<T> doLocalExport(final Invoker<T> originInvoker, URL providerUrl) {
    String key = getCacheKey(originInvoker);
    //bounds -chm  ->computeIfAbsent  if(map.get(key)==null){map.put()}
    return (ExporterChangeableWrapper<T>) bounds.computeIfAbsent(key, s -> {
        //orginInvoker->   InvokerDelegate(DelegateProviderMetaDataInvoker(invoker))
        Invoker<?> invokerDelegate = new InvokerDelegate<>(originInvoker, providerUrl);
        //protocol.export -> DubboProtocol.export(本质上就是 暴露一个 20880的端口）
        //protocol- >Protocol$Apaptive ->QosProtocolWrapper(ProtocolListenerWrapper(ProtocolFilterWrapper(DubboProtocol(invoker)))) 包装器调用，最后调用到 DubboProtocol
        return new ExporterChangeableWrapper<>((Exporter<T>) protocol.export(invokerDelegate), originInvoker);
    });
}
```



#### DubboProtocol.export()



```java
public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
    URL url = invoker.getUrl();

    // export service.
    String key = serviceKey(url);
    DubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);
    exporterMap.put(key, exporter);

    //export an stub service for dispatching event
    Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);
    Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, false);
    if (isStubSupportEvent && !isCallbackservice) {
        String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);
        if (stubServiceMethods == null || stubServiceMethods.length() == 0) {
            if (logger.isWarnEnabled()) {
                logger.warn(new IllegalStateException("consumer [" + url.getParameter(INTERFACE_KEY) +
                                                      "], has set stubproxy support event ,but no stub methods founded."));
            }

        } else {
            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);
        }
    }

    openServer(url); //openServer（url） 开启一个服务 ，暴露20880端口
    optimizeSerialization(url);  //优化序列化

    return exporter;
}
```



#### DubboProtocol.openServer()



```java
private void openServer(URL url) {
    // find server.
    String key = url.getAddress();
    //client can export a service which's only for server to invoke
    boolean isServer = url.getParameter(IS_SERVER_KEY, true);
    if (isServer) {
        //缓存， 一个key只对应一个exchangeServer
        ExchangeServer server = serverMap.get(key);
        if (server == null) {
            synchronized (this) {
                server = serverMap.get(key);
                if (server == null) {
                    // 创建服务
                    serverMap.put(key, createServer(url));
                }
            }
        } else {
            // server supports reset, use together with override
            server.reset(url);
        }
    }
}

```



#### DubboProtocol.createServer()



```java
private ExchangeServer createServer(URL url) {
    url = URLBuilder.from(url)
        // send readonly event when server closes, it's enabled by default
        .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())
        // enable heartbeat by default
        .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))
        .addParameter(CODEC_KEY, DubboCodec.NAME)
        .build();
    //获得当前应该采用什么样的方式来发布服务， netty3, netty4, mina , grizzy,
    String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);

    if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {
        throw new RpcException("Unsupported server type: " + str + ", url: " + url);
    }

    ExchangeServer server;
    try {
        server = Exchangers.bind(url, requestHandler);
    } catch (RemotingException e) {
        throw new RpcException("Fail to start server(url: " + url + ") " + e.getMessage(), e);
    }

    str = url.getParameter(CLIENT_KEY);
    if (str != null && str.length() > 0) {
        Set<String> supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();
        if (!supportedTypes.contains(str)) {
            throw new RpcException("Unsupported client type: " + str);
        }
    }

    return server;
}
```



#### AbstractRegistryFactory.getRegistry()



```java
public Registry getRegistry(URL url) {
    url = URLBuilder.from(url)
        .setPath(RegistryService.class.getName())
        .addParameter(INTERFACE_KEY, RegistryService.class.getName())
        .removeParameters(EXPORT_KEY, REFER_KEY)
        .build();
    String key = url.toServiceStringWithoutResolving();
    // Lock the registry access process to ensure a single instance of the registry
    LOCK.lock();
    try {
        Registry registry = REGISTRIES.get(key);
        if (registry != null) {
            return registry;
        }
        //create registry by spi/ioc
        // 创建注册中心
        registry = createRegistry(url);
        if (registry == null) {
            throw new IllegalStateException("Can not create registry " + url);
        }
        REGISTRIES.put(key, registry);
        return registry;
    } finally {
        // Release the lock
        LOCK.unlock();
    }
}
```





#### AbstractRegistryFactory.createRegistry()

```java
protected Registry createRegistry(URL url) {
    // 通过生成的RegistryFactory$Adaptive 调用
    // 根据协议zookeeper:// 
    // 调用ZookeeperRegistryFactory 类中方法
    return createRegistry(new com.alibaba.dubbo.common.URL(url));
}
```



#### ZookeeperRegistryFactory.createRegistry()

```java
public Registry createRegistry(URL url) {
    return new ZookeeperRegistry(url, zookeeperTransporter);
}
```



#### ZookeeperRegistry构造

```java
public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) {
    super(url);
    if (url.isAnyHost()) {
        throw new IllegalStateException("registry address == null");
    }
    String group = url.getParameter(GROUP_KEY, DEFAULT_ROOT);
    if (!group.startsWith(PATH_SEPARATOR)) {
        group = PATH_SEPARATOR + group;
    }
    this.root = group;
    // 启动一个zookeeper 连接 
    // 后续启动就分析了，就是创建zk节点信息、监听等等
    zkClient = zookeeperTransporter.connect(url);
    // 添加状态事件监听
    zkClient.addStateListener(state -> {
        if (state == StateListener.RECONNECTED) {
            try {
                recover();
            } catch (Exception e) {
                logger.error(e.getMessage(), e);
            }
        }
    });
}
```



#### RegistryProtocol.register()

```java
public void register(URL registryUrl, URL registeredProviderUrl) {
  Registry registry = registryFactory.getRegistry(registryUrl);
  registry.register(registeredProviderUrl);
}
```



## Invoker

从前面的分析来看，服务发布分为三个阶段

第一个阶段会创造一个invoker

第二个阶段会把经历过一系列处理的invoker，在DubboProtocol中保存到exportMap中

第三个阶段会把dubbo协议的url地址注册到注册中心上



从上面代码看 `Invoker` 是什么

```java
Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));
```

### ProxyFactory.getInvoker()

这是一个代理工程，用来生成Invoker，从它的定义来看，它是一个自适应扩展点

```JAVA
private static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();
```

`ProxyFactory` 是一个SPI扩展点，默认使用javassist实现。

```java
@SPI("javassist")
public interface ProxyFactory {

    @Adaptive({PROXY_KEY})
    <T> T getProxy(Invoker<T> invoker) throws RpcException;

    @Adaptive({PROXY_KEY})
    <T> T getProxy(Invoker<T> invoker, boolean generic) throws RpcException;

    @Adaptive({PROXY_KEY})
    <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;

}
```





### JavassistProxyFactory

```java
public class JavassistProxyFactory extends AbstractProxyFactory {

    @Override
    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {
        // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'
        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);
        return new AbstractProxyInvoker<T>(proxy, type, url) {
            @Override
            protected Object doInvoke(T proxy, String methodName,
                                      Class<?>[] parameterTypes,
                                      Object[] arguments) throws Throwable {
                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
            }
        };
    }

}
```





# dubbo 2.7.2 服务消费

如果要实现服务消费，需要步骤

1. 生成远程服务的代理
2. 获得目标服务的url地址
3. 实现远程网络通信
4. 实现负载均衡
5. 实现集群容错



## 服务消费

### ReferenceBean.afterPropertiesSet()

```java
public void afterPropertiesSet() throws Exception {
  // 省略代码... 
  // 解析配置文件相关
  if (shouldInit()) {
    // 获得对象
    getObject();
  }
}

public Object getObject() {
  return get();
}

```

### ReferenceConfig.get()

```java
//返回一个代理对象（）
public synchronized T get() {
  checkAndUpdateSubConfigs(); //检查配置和完善配置

  if (destroyed) {
    throw new IllegalStateException("The invoker of ReferenceConfig(" + url + ") has already destroyed!");
  }
  if (ref == null) { //ref还没有生成的时候，init
    init();
  }
  return ref;
}
```



### RefercenceConfig.init()

```java
private void init() {
  // 省略
  // 处理url

  //registry: 192.168.1.13:2181
  String hostToRegistry = ConfigUtils.getSystemProperty(DUBBO_IP_TO_REGISTRY);
  if (StringUtils.isEmpty(hostToRegistry)) {
    hostToRegistry = NetUtils.getLocalHost(); //0.0.0.0
  } else if (isInvalidLocalHost(hostToRegistry)) {
    throw new IllegalArgumentException("Specified invalid registry ip from property:" + DUBBO_IP_TO_REGISTRY + ", value:" + hostToRegistry);
  }
  map.put(REGISTER_IP_KEY, hostToRegistry);

  ref = createProxy(map); //真正意义上去构建proxy


  String serviceKey = URL.buildKey(interfaceName, group, version);
  ApplicationModel.initConsumerModel(serviceKey, buildConsumerModel(serviceKey, attributes));
  initialized = true;
}
```



### ReferenceConfig.createProxy()

```java
private T createProxy(Map<String, String> map) {
  if (shouldJvmRefer(map)) {//是否在injvm
    URL url = new URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, 0, interfaceClass.getName()).addParameters(map);
    invoker = REF_PROTOCOL.refer(interfaceClass, url);
    if (logger.isInfoEnabled()) {
      logger.info("Using injvm service " + interfaceClass.getName());
    }
  } else {
    urls.clear(); // reference retry init will add url to urls, lead to OOM
    //url -> 点对点 ()
    if (url != null && url.length() > 0) { // user specified URL, could be peer-to-peer address, or register center's address.
      String[] us = SEMICOLON_SPLIT_PATTERN.split(url);
      if (us != null && us.length > 0) {
        for (String u : us) {
          URL url = URL.valueOf(u);
          if (StringUtils.isEmpty(url.getPath())) {
            url = url.setPath(interfaceName);
          }
          if (REGISTRY_PROTOCOL.equals(url.getProtocol())) {
            urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));
          } else {
            urls.add(ClusterUtils.mergeUrl(url, map));
          }
        }
      }
    } else {//从注册中心去获得服务地址
      // if protocols not injvm checkRegistry
      if (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())){
        checkRegistry();
        //us: registry://
        List<URL> us = loadRegistries(false);
        if (CollectionUtils.isNotEmpty(us)) {
          for (URL u : us) {
            URL monitorUrl = loadMonitor(u);
            if (monitorUrl != null) {
              map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));
            }
            urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));
          }
        }
        if (urls.isEmpty()) {
          throw new IllegalStateException("No such any registry to reference " + interfaceName + " on the consumer " + NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion() + ", please config <dubbo:registry address=\"...\" /> to your spring config.");
        }
      }
    }
    //urls.size=1;()
    if (urls.size() == 1) {
      //构建一个invoker(Protocol)
      //Protocol$Adaptive -> getExtension("registry")->Qos(listener(filter(RegisterProtol
      //RegisterProtocol.refer()
      invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(0));
    } else {
      List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();
      URL registryURL = null;
      for (URL url : urls) {
        invokers.add(REF_PROTOCOL.refer(interfaceClass, url));
        if (REGISTRY_PROTOCOL.equals(url.getProtocol())) {
          registryURL = url; // use last registry url
        }
      }
      if (registryURL != null) { // registry url is available
        // use RegistryAwareCluster only when register's CLUSTER is available
        URL u = registryURL.addParameter(CLUSTER_KEY, RegistryAwareCluster.NAME);
        // The invoker wrap relation would be: RegistryAwareClusterInvoker(StaticDirectory) -> FailoverClusterInvoker(RegistryDirectory, will execute route) -> Invoker
        invoker = CLUSTER.join(new StaticDirectory(u, invokers));
      } else { // not a registry url, must be direct invoke.
        invoker = CLUSTER.join(new StaticDirectory(invokers));
      }
    }
  }

  if (shouldCheck() && !invoker.isAvailable()) {
    throw new IllegalStateException("Failed to check the status of the service " + interfaceName + ". No provider available for the service " + (group == null ? "" : group + "/") + interfaceName + (version == null ? "" : ":" + version) + " from the url " + invoker.getUrl() + " to the consumer " + NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion());
  }
  if (logger.isInfoEnabled()) {
    logger.info("Refer dubbo service " + interfaceClass.getName() + " from url " + invoker.getUrl());
  }
  /**
         * @since 2.7.0
         * ServiceData Store
         */
  MetadataReportService metadataReportService = null;
  if ((metadataReportService = getMetadataReportService()) != null) {
    URL consumerURL = new URL(CONSUMER_PROTOCOL, map.remove(REGISTER_IP_KEY), 0, map.get(INTERFACE_KEY), map);
    metadataReportService.publishConsumer(consumerURL);
  }
  // create service proxy
  return (T) PROXY_FACTORY.getProxy(invoker);
}

```





### RegistryProtocol.refer()

```java
public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
  //zookeeper://
  url = URLBuilder.from(url)
    .setProtocol(url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY))
    .removeParameter(REGISTRY_KEY)
    .build();
  //ZookeeperRegistery
  Registry registry = registryFactory.getRegistry(url);
  //register://
  if (RegistryService.class.equals(type)) {
    return proxyFactory.getInvoker((T) registry, type, url);
  }

  // group="a,b" or group="*"
  Map<String, String> qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));
  String group = qs.get(GROUP_KEY);
  if (group != null && group.length() > 0) {
    if ((COMMA_SPLIT_PATTERN.split(group)).length > 1 || "*".equals(group)) {
      return doRefer(getMergeableCluster(), registry, type, url);
    }
  }
  //Cluster
  return doRefer(cluster, registry, type, url);
}
```

### RegistryProtocol.doRefer()

```java
private <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {

  /******************************************/
  // 构建一个consumer://ip:port  保存到zk   provider /configurator/consumer/router
  // 1. 连接到注册中心 ->curator
  // 2. 从注册中心拿到地址（providerUrl）
  // 3. 基于provider地址建立通信
  RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);
  directory.setRegistry(registry); //registry -> 连接zk的api   ->获得url地址
  directory.setProtocol(protocol); //protocol -> DubboProtocol()  -> 建立通信
  // all attributes of REFER_KEY
  Map<String, String> parameters = new HashMap<String, String>(directory.getUrl().getParameters());
  URL subscribeUrl = new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);
  if (!ANY_VALUE.equals(url.getServiceInterface()) && url.getParameter(REGISTER_KEY, true)) {
    directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));
    registry.register(directory.getRegisteredConsumerUrl()); //consumer://
  }
  directory.buildRouterChain(subscribeUrl);
  //订阅
  directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,
                                                PROVIDERS_CATEGORY + "," + CONFIGURATORS_CATEGORY + "," + ROUTERS_CATEGORY));
  /******************************************/


  //MockClusterWrapper(FailoverCluster(
  //Directory
  Invoker invoker = cluster.join(directory);
  ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);
  return invoker;
}
```



## Cluster

关注Invoker这个代理类创建过程

```java
cluster.join(directory);
```

Cluster 是一个自适应扩展点，那么会动态生成一个动态代理类

### Cluster$Adaptive

在动态适配的类中会基于 `extName` 选择一个合适的扩展点进行适配，由于默认情况下是`cluter:failover`，所以会返回`FailOverCLuster`，而且这里做了包装`MockCLusterWrapper` 。所以最后生成的是`MockCLusterWrapper(FailOverCLuster())`



### proxyFactory.getProxy()

`RefercenConfig.createProxy` 中的最后一行，通过默认的`JavassistProxyFactory` 生成一个动态代理类。

```java
return (T) PROXY_FACTORY.getProxy(invoker);
```



所以从本质上来看，`@Reference` 注入的对象实例本质上就是动态代理类，通过调用这个类中的方法，会触发handler.invoke()。



## 网络连接的建立

继续`RegitstryProtocol.doRefer()` 分析 `directory.subscribe`,它是实现服务目标订阅订阅的。

```java
directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,
                PROVIDERS_CATEGORY + "," + CONFIGURATORS_CATEGORY + "," + ROUTERS_CATEGORY));
```

### RegistryDirectory.subscribe()

```java
public void subscribe(URL url) {
  setConsumerUrl(url);
  // 把当前RegistryDirectory作为lister，去监听zk上的节点变化
  CONSUMER_CONFIGURATION_LISTENER.addNotifyListener(this);
  serviceConfigurationListener = new ReferenceConfigurationListener(this, url);
  //ZookeeperRegistry  ; listener: this ->RegistryDirectory
  // 订阅
  registry.subscribe(url, this);
}
```



### FailbackRegistry.subscribe()

```java
public void subscribe(URL url, NotifyListener listener) {
  super.subscribe(url, listener);
  removeFailedSubscribed(url, listener);
  try {
    // Sending a subscription request to the server side
    doSubscribe(url, listener);
  } catch (Exception e) {
    Throwable t = e;

    List<URL> urls = getCacheUrls(url);
    if (CollectionUtils.isNotEmpty(urls)) {
      notify(url, listener, urls);
      logger.error("Failed to subscribe " + url + ", Using cached list: " + urls + " from cache file: " + getUrl().getParameter(FILE_KEY, System.getProperty("user.home") + "/dubbo-registry-" + url.getHost() + ".cache") + ", cause: " + t.getMessage(), t);
    } else {
      // If the startup detection is opened, the Exception is thrown directly.
      boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)
        && url.getParameter(Constants.CHECK_KEY, true);
      boolean skipFailback = t instanceof SkipFailbackWrapperException;
      if (check || skipFailback) {
        if (skipFailback) {
          t = t.getCause();
        }
        throw new IllegalStateException("Failed to subscribe " + url + ", cause: " + t.getMessage(), t);
      } else {
        logger.error("Failed to subscribe " + url + ", waiting for retry, cause: " + t.getMessage(), t);
      }
    }

    // Record a failed registration request to a failed list, retry regularly
    addFailedSubscribed(url, listener);
  }
}
```

### ZookeeperRegistry.doSubscribe()



```java
public void doSubscribe(final URL url, final NotifyListener listener) {
  try {
    if (ANY_VALUE.equals(url.getServiceInterface())) {
     // ....
    } else {
      List<URL> urls = new ArrayList<>();
      //configurator/ consumer/ router
      for (String path : toCategoriesPath(url)) {
        ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);
        // 如果之前没有监听，则创建一个监听
        if (listeners == null) {
          zkListeners.putIfAbsent(url, new ConcurrentHashMap<>());
          listeners = zkListeners.get(url);
        }
        ChildListener zkListener = listeners.get(listener);
        // 没有对子节点的监听，则创建，通知变化
        if (zkListener == null) {
          listeners.putIfAbsent(listener, (parentPath, currentChilds) -> ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds)));
          zkListener = listeners.get(listener);
        }
        zkClient.create(path, false);
        //对子节点进行监听，获取子节点的信息 ->children : providerUrl
        //
        List<String> children = zkClient.addChildListener(path, zkListener);
        if (children != null) {
          urls.addAll(toUrlsWithEmpty(url, path, children));
        }
      }
      // 进行通知
      notify(url, listener, urls);
    }
  } catch (Throwable e) {
    throw new RpcException("Failed to subscribe " + url + " to zookeeper " + getUrl() + ", cause: " + e.getMessage(), e);
  }
}

```

### FailbackRegistry.notify()

```java
protected void notify(URL url, NotifyListener listener, List<URL> urls) {
  if (url == null) {
    throw new IllegalArgumentException("notify url == null");
  }
  if (listener == null) {
    throw new IllegalArgumentException("notify listener == null");
  }
  try {
    doNotify(url, listener, urls);
  } catch (Exception t) {
    // Record a failed registration request to a failed list, retry regularly
    addFailedNotified(url, listener, urls);
    logger.error("Failed to notify for subscribe " + url + ", waiting for retry, cause: " + t.getMessage(), t);
  }
}
protected void doNotify(URL url, NotifyListener listener, List<URL> urls) {
  super.notify(url, listener, urls);
}
```



### AbstractRegistry.notify()

针对每一个cateGory，调用listener.notify() 进行通知，然后更新本地缓存。

```java
protected void notify(URL url, NotifyListener listener, List<URL> urls) {
  // .......
  // keep every provider's category.
  Map<String, List<URL>> result = new HashMap<>();
  for (URL u : urls) {
    if (UrlUtils.isMatch(url, u)) {
      String category = u.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY);
      List<URL> categoryList = result.computeIfAbsent(category, k -> new ArrayList<>());
      categoryList.add(u);
    }
  }
  if (result.size() == 0) {
    return;
  }
  Map<String, List<URL>> categoryNotified = notified.computeIfAbsent(url, u -> new ConcurrentHashMap<>());
  for (Map.Entry<String, List<URL>> entry : result.entrySet()) {
    String category = entry.getKey();
    List<URL> categoryList = entry.getValue();
    categoryNotified.put(category, categoryList);
    // 通知？ RegistryDirectory
    listener.notify(categoryList);
    // We will update our cache file after each notification.
    // When our Registry has a subscribe failure due to network jitter, we can return at least the existing cache URL.
    //dubbo:// 保存到文件中
    saveProperties(url);
  }
}
```



### RegistryDirectory.notify()

Invoker的网络连接以后后续的配置变更都会调用这个notify方法。

```java
public synchronized void notify(List<URL> urls) {
  // 对url进行校验
  Map<String, List<URL>> categoryUrls = urls.stream()
    .filter(Objects::nonNull)
    .filter(this::isValidCategory)
    .filter(this::isNotCompatibleFor26x)
    .collect(Collectors.groupingBy(url -> {
      if (UrlUtils.isConfigurator(url)) {
        return CONFIGURATORS_CATEGORY;
      } else if (UrlUtils.isRoute(url)) {
        return ROUTERS_CATEGORY;
      } else if (UrlUtils.isProvider(url)) {
        return PROVIDERS_CATEGORY;
      }
      return "";
    }));

  List<URL> configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList());
  this.configurators = Configurator.toConfigurators(configuratorURLs).orElse(this.configurators);
	// 如果是router节点有变化，则重新将router下的数据生成router
  List<URL> routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList());
  toRouters(routerURLs).ifPresent(this::addRouters);

  // providers
  List<URL> providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());
  //刷新或者覆盖invoker
  //providerURLs:  dubboo://ip:port
  refreshOverrideAndInvoker(providerURLs);
}

```

### RegistryDirectory.refreshOverrideAndInvoker()

```java
private void refreshOverrideAndInvoker(List<URL> urls) {
  // mock zookeeper://xxx?mock=return null
  overrideDirectoryUrl(); //覆盖
  refreshInvoker(urls); //刷新
}
```







```java
private void refreshInvoker(List<URL> invokerUrls) {
  Assert.notNull(invokerUrls, "invokerUrls should not be null");

  if (invokerUrls.size() == 1
      && invokerUrls.get(0) != null
      && EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {
    this.forbidden = true; // Forbid to access
    this.invokers = Collections.emptyList();
    routerChain.setInvokers(this.invokers);
    destroyAllInvokers(); // Close all invokers
  } else {
    this.forbidden = false; // Allow to access
    Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap; // local reference
    if (invokerUrls == Collections.<URL>emptyList()) {
      invokerUrls = new ArrayList<>();
    }
    if (invokerUrls.isEmpty() && this.cachedInvokerUrls != null) {
      invokerUrls.addAll(this.cachedInvokerUrls);
    } else {
      this.cachedInvokerUrls = new HashSet<>();
      this.cachedInvokerUrls.addAll(invokerUrls);//Cached invoker urls, convenient for comparison
    }
    if (invokerUrls.isEmpty()) {
      return;
    }
    //toInvokers ，把invokerUrls 转化为invoker->
    Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map

    if (CollectionUtils.isEmptyMap(newUrlInvokerMap)) {
      logger.error(new IllegalStateException("urls to invokers error .invokerUrls.size :" + invokerUrls.size() + ", invoker.size :0. urls :" + invokerUrls
                                             .toString()));
      return;
    }

    List<Invoker<T>> newInvokers = Collections.unmodifiableList(new ArrayList<>(newUrlInvokerMap.values()));
    // pre-route and build cache, notice that route cache should build on original Invoker list.
    // toMergeMethodInvokerMap() will wrap some invokers having different groups, those wrapped invokers not should be routed.
    // 如果配置了分组，就按照group 进行合并
    routerChain.setInvokers(newInvokers);
    this.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;
    this.urlInvokerMap = newUrlInvokerMap;

    try {
      // 销毁旧的Invoker
      destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // Close the unused Invoker
    } catch (Exception e) {
      logger.warn("destroyUnusedInvokers error. ", e);
    }
  }
}
```



### RegistryDirectory.toInvokers()

```java
private Map<String, Invoker<T>> toInvokers(List<URL> urls) {
  Map<String, Invoker<T>> newUrlInvokerMap = new HashMap<>();
  if (urls == null || urls.isEmpty()) {
    return newUrlInvokerMap;
  }
  Set<String> keys = new HashSet<>();
  String queryProtocols = this.queryMap.get(PROTOCOL_KEY);
  for (URL providerUrl : urls) {
    // If protocol is configured at the reference side, only the matching protocol is selected
    if (queryProtocols != null && queryProtocols.length() > 0) {
      boolean accept = false;
      String[] acceptProtocols = queryProtocols.split(",");
      for (String acceptProtocol : acceptProtocols) {
        if (providerUrl.getProtocol().equals(acceptProtocol)) {
          accept = true;
          break;
        }
      }
      if (!accept) {
        continue;
      }
    }
    if (EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {
      continue;
    }
    if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {
      logger.error(new IllegalStateException("Unsupported protocol " + providerUrl.getProtocol() +
                                             " in notified url: " + providerUrl + " from registry " + getUrl().getAddress() +
                                             " to consumer " + NetUtils.getLocalHost() + ", supported protocol: " +
                                             ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));
      continue;
    }
    URL url = mergeUrl(providerUrl);

    String key = url.toFullString(); // The parameter urls are sorted
    if (keys.contains(key)) { // Repeated url
      continue;
    }
    keys.add(key);
    // Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again
    Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap; // local reference
    Invoker<T> invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);
    if (invoker == null) { // Not in the cache, refer again
      try {
        boolean enabled = true;
        if (url.hasParameter(DISABLED_KEY)) {
          enabled = !url.getParameter(DISABLED_KEY, false);
        } else {
          enabled = url.getParameter(ENABLED_KEY, true);
        }
        if (enabled) {
          invoker = new InvokerDelegate<>(protocol.refer(serviceType, url), url, providerUrl);
        }
      } catch (Throwable t) {
        logger.error("Failed to refer invoker for interface:" + serviceType + ",url:(" + url + ")" + t.getMessage(), t);
      }
      if (invoker != null) { // Put new invoker in cache
        newUrlInvokerMap.put(key, invoker);
      }
    } else {
      newUrlInvokerMap.put(key, invoker);
    }
  }
  keys.clear();
  return newUrlInvokerMap;
}

```



### DubboProtocol.refer()

`protocol.refer` 是一个自适应扩展点，真正调用的是`DubboProtocol.protocolBindingRefer`。

`DubboProtocol.protocolBindingRefer ` 主要做了两件事

1. 优化序列化
2. 构建DubboInvoker



### DubboProtocol.protocolBindingRefer()

```java
public <T> Invoker<T> protocolBindingRefer(Class<T> serviceType, URL url) throws RpcException {
  optimizeSerialization(url);

  // create rpc invoker.
  //getClients(url)
  DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClients(url), invokers);
  invokers.add(invoker);

  return invoker;
}
```



### DubboProtocol.getClients()

```java
private ExchangeClient[] getClients(URL url) {
  // whether to share connection

  boolean useShareConnect = false;

  int connections = url.getParameter(CONNECTIONS_KEY, 0);
  List<ReferenceCountExchangeClient> shareClients = null;
  // if not configured, connection is shared, otherwise, one connection for one service
  if (connections == 0) {
    useShareConnect = true;

    
    String shareConnectionsStr = url.getParameter(SHARE_CONNECTIONS_KEY, (String) null);
    connections = Integer.parseInt(StringUtils.isBlank(shareConnectionsStr) ? ConfigUtils.getProperty(SHARE_CONNECTIONS_KEY,
                                                                                                      DEFAULT_SHARE_CONNECTIONS) : shareConnectionsStr);
    // 获取一个共享连接
    shareClients = getSharedClient(url, connections);
  }

  ExchangeClient[] clients = new ExchangeClient[connections];
  for (int i = 0; i < clients.length; i++) {
    if (useShareConnect) {
      clients[i] = shareClients.get(i);

    } else {
      clients[i] = initClient(url);
    }
  }

  return clients;
}
```



### DubboProtocol.getSharedClient()

```java
private List<ReferenceCountExchangeClient> getSharedClient(URL url, int connectNum) {
  String key = url.getAddress();
  List<ReferenceCountExchangeClient> clients = referenceClientMap.get(key);
	// 检查当前key是否创建连接并且可用
  if (checkClientCanUse(clients)) {
    batchClientRefIncr(clients);
    return clients;
  }

  locks.putIfAbsent(key, new Object());
  synchronized (locks.get(key)) {
    clients = referenceClientMap.get(key);
    // dubbo check
    // 创建前做一次检查
    if (checkClientCanUse(clients)) {
      batchClientRefIncr(clients);
      return clients;
    }

    // connectNum must be greater than or equal to 1
    connectNum = Math.max(connectNum, 1);

    // If the clients is empty, then the first initialization is
    if (CollectionUtils.isEmpty(clients)) {
      clients = buildReferenceCountExchangeClientList(url, connectNum);
      referenceClientMap.put(key, clients);

    } else {
      for (int i = 0; i < clients.size(); i++) {
        ReferenceCountExchangeClient referenceCountExchangeClient = clients.get(i);
        // If there is a client in the list that is no longer available, create a new one to replace him.
        if (referenceCountExchangeClient == null || referenceCountExchangeClient.isClosed()) {
          clients.set(i, buildReferenceCountExchangeClient(url));
          continue;
        }

        referenceCountExchangeClient.incrementAndGetCount();
      }
    }

    /**
             * I understand that the purpose of the remove operation here is to avoid the expired url key
             * always occupying this memory space.
             */
    locks.remove(key);

    return clients;
  }
}
```



### DubboProtocol.buildReferenceCountExchangeClientList()

根据连接数配置，来构建指定个数的链接

```java
private List<ReferenceCountExchangeClient> buildReferenceCountExchangeClientList(URL url, int connectNum) {
  List<ReferenceCountExchangeClient> clients = new ArrayList<>();

  for (int i = 0; i < connectNum; i++) {
    clients.add(buildReferenceCountExchangeClient(url));
  }

  return clients;
}

private ReferenceCountExchangeClient buildReferenceCountExchangeClient(URL url) {
  ExchangeClient exchangeClient = initClient(url);

  return new ReferenceCountExchangeClient(exchangeClient);
}
```



### DubboProtocol.initClient()

```java
private ExchangeClient initClient(URL url) {

  // client type setting.
  // 获取连接类型
  String str = url.getParameter(CLIENT_KEY, url.getParameter(SERVER_KEY, DEFAULT_REMOTING_CLIENT));
	//设置默认序列化方式
  url = url.addParameter(CODEC_KEY, DubboCodec.NAME);
  // enable heartbeat by default
  // 设置心跳时间
  url = url.addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT));

  // BIO is not allowed since it has severe performance issue.
  // 判断str是否存在于扩展点
  if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {
    throw new RpcException("Unsupported client type: " + str + "," +
                           " supported client type is " + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), " "));
  }

  ExchangeClient client;
  try {
    // connection should be lazy
    // 是否延迟创建连接
    if (url.getParameter(LAZY_CONNECT_KEY, false)) {
      client = new LazyConnectExchangeClient(url, requestHandler);

    } else {
      client = Exchangers.connect(url, requestHandler);
    }

  } catch (RemotingException e) {
    throw new RpcException("Fail to create remoting client for service(" + url + "): " + e.getMessage(), e);
  }

  return client;
}

```



### Exchangers.connect()

创建一个客户端连接

```java
public static ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {
  if (url == null) {
    throw new IllegalArgumentException("url == null");
  }
  if (handler == null) {
    throw new IllegalArgumentException("handler == null");
  }
  url = url.addParameterIfAbsent(Constants.CODEC_KEY, "exchange");
  return getExchanger(url).connect(url, handler);
}

public static Exchanger getExchanger(URL url) {
  String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);
  return getExchanger(type);
}

public static Exchanger getExchanger(String type) {
  return ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);
}
```













































