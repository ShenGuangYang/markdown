# Java 线程基础



## volatile

### 初步认识volatile

下面这段代码，演示了一个使用 volatile 以及没使用 volatile 这个关键字，对于变量更新的影响

```java
public class VolatileDemo {
    public /*volatile*/ static boolean is_stop = false;

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (!is_stop) {
            }
        });
        thread.start();
        System.out.println("begin start thread");
        thread.sleep(1000);
        is_stop = true;
    }
}
```



### volatile 的作用

volatile 可以使得在多处理器环境下保证了共享变量的可见性，那么到底什么是可见性呢？

可见性：在单线程的环境下，如果向一个变量先写入一个值，然后在没有写干涉的情况下读取这个变量的值，那这个时候读取到的这个变量的值应该是之前写入的那个值。这本来是一个很正常的事情。但是在多线程环境下，读和写发生在不同的线程中的时候，可能会出现，读线程不能及时的读取到其它线程写入的最新值。

为了实现跨线程写入的内存可见性，必须使用到一些机制来实现。而 volatile 就是这样一种机制。

**volatile 关键字是如何保证可见性的？**

使用hsdis-amd64.dll 查看前面演示的这段代码的汇编指令。

在运行的代码中，设置jvm参数如下：

```
-server 
-Xcomp 
-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly 
-XX:CompileCommand=compileonly,*TestDemo.*
```

在修改带有 volatile 修饰的成员变量时，会多一个lock指令。lock是一种控制指令，在多处理器环境下，lock 汇编指令可以基础总线锁或者缓存锁的机制来达到可见性的一个效果。



## JMM

JMM 全程是java memory model 。（java内存模型）

导致可见性问题的根本原因是缓存以及重排序。而JMM实际上就是提供了合理的禁用缓存以及禁止重排序的方法。所以它最核心的价值在于解决可见性和有序性。

JMM 属于语言级别的抽象内存模型，可以简单理解为对硬件模型的抽象，它定义了共享内存中多线程程序读写操作的行为规范：在虚拟机中把共享变量存储到内存以及从内存中取出共享变量的底层实现细节。

通过这些规则来规范对内存的读写操作从而保证指令的正确性，它解决了CPU多级缓存、处理器优化、指令重排序导致的内存访问问题，保证了并发场景下的可见性。

需要注意的是，JMM 并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序，也就是说在JMM中，也会存在缓存一致性问题和指令重排序问题。只是 JMM 把底层的问题抽象到 JMM 层面，在基于CPU层面提供的内存屏障指令，以及限制编译器的重排序来解决并发问题。

















