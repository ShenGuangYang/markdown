# 七大设计原则



## 开闭原则

对扩展开放，对修改关闭

## 单一职责原则

约定一个类、接口、方法只做一件事，保证单一性

## 依赖倒置原则

通过抽象的接口、类，使得各个类相互不影响

## 接口隔离原则

尽量去保证接口的纯洁性，客户端不应该依赖不需要的接口

## 迪米特法则（最少知道原则）

一个类所依赖的类知道的越少越好

## 里氏替换原则

子类可以扩展父类的功能，但是不能改变父类原来的功能

## 合成复用原则

尽量去使用对象的组合聚合，而不使用集成关系到达复用关系



# 设计模式



## 工厂模式



### 简单工厂模式（Simple Factory Pattern）

是指一个工厂对象决定创建出哪一种产品类的实例。

属于创建型模式，但它不属于GOF 23种设置模式。

> 优点：
>
> - 只需要传入一个正确的参数，就可以创建所需要的对象，不需要知道创建的细节
>
> 缺点：
>
> - 工厂类的职责过重，增加新的产品需要修改工厂类的判断逻辑，违背开闭原则
> - 不易于扩展过于复杂的产品结构

以创建课程为例：

```java
public interface ICourse {
    void record();
}
```

```java
public class JavaCourse implements ICourse {
    @Override
    public void record() {
        System.out.println("录制java课程");
    }
}
```

```java
public class PythonCourse implements ICourse {
    @Override
    public void record() {
        System.out.println("录制Python课程");
    }
}
```

```java
public class SimpleFactory {
    private SimpleFactory() {}
    public static ICourse create(String name) {
        if ("java".equalsIgnoreCase(name)) {
            return new JavaCourse();
        } else if ("python".equalsIgnoreCase(name)) {
            return new PythonCourse();
        } else {
            return null;
        }
    }
    public static <T> T create(Class<T> clazz) {
        try {
            if (clazz != null) {
                return clazz.newInstance();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

```java
public class SimpleFactoryTest {
    public static void main(String[] args) throws Exception{
        ICourse course = SimpleFactory.create("java");
        course.record();
        ICourse course1 = SimpleFactory.create(JavaCourse.class);
        course1.record();
    }
}
```



代码 UML 类图：

![simple-factory](../img/dp/simple-factory.png)

### 工厂方法模式（Factory Method Pattern）

是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。

属于创建型设计模式。

> 优点：
>
> - 只关心所需产品对应的工厂，无需关心创建细节
> - 加入新产品符合开闭原则，提高了系统的扩展性
>
> 缺点：
>
> - 类容易过多，增加代码结构的复杂度
> - 增加了系统的抽象性和理解难度

以创建课程为例：

```java
public interface ICourse {
    void record();
}
```

```java
public class JavaCourse implements ICourse {
    @Override
    public void record() {
        System.out.println("录制java课程");
    }
}
```

```java
public class PythonCourse implements ICourse {
    @Override
    public void record() {
        System.out.println("录制Python课程");
    }
}
```

```java
public interface ICourseFactory {
    ICourse create();
}
```

```java
public class JavaCourseFactory implements ICourseFactory {
    @Override
    public ICourse create() {
        return new JavaCourse();
    }
}
```

```java
public class PythonCourseFactory implements ICourseFactory {
    @Override
    public ICourse create() {
        return new PythonCourse();
    }
}
```

```java
public class FactoryMethodTest {
    public static void main(String[] args) {
        ICourseFactory javaCourseFactory = new JavaCourseFactory();
        ICourse javaCourse = javaCourseFactory.create();
        javaCourse.record();
        ICourseFactory pythonCourseFactory = new PythonCourseFactory();
        ICourse pythonCourse = pythonCourseFactory.create();
        pythonCourse.record();
    }
}
```

代码 UML 类图：

![factory-method](../img/dp/factory-method.png)



### 抽象工厂（Abstract Factory Pattern）

是指提供一个创建一系列相关或相互依赖对象的接口，无需知道他们的具体类。

属于创建型模式。

> 优点：
>
> - 具体产品在应用层代码隔离，无需关系创建细节
> - 可以将一个系列的产品族统一到一起创建
>
> 缺点：
>
> - 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂接口
> - 增加了系统的抽象性和理解难度

以创建课程为例：

```java
// 产品族的抽象
public interface ICourse {
    void record();
}
```

```java
public class JavaCourse implements ICourse {
    @Override
    public void record() {
        System.out.println("录制java课程");
    }
}
```

```java
public class PythonCourse implements ICourse {
    @Override
    public void record() {
        System.out.println("录制Python课程");
    }
}
```

```java
// 产品族的抽象
public interface INote {
    void takeNote();
}
```

```java
public class JavaNote implements INote{
    @Override
    public void takeNote() {
        System.out.println("记java笔记");
    }
}
```

```java
public class PythonNote implements INote{
    @Override
    public void takeNote() {
        System.out.println("记python笔记");
    }
}
```

```java
// 产品等级的抽象
public interface ICourseFactory {
    ICourse createCourse();
    INote createNote();
}
```

```java
public class JavaCourseFactory implements ICourseFactory {
    @Override
    public ICourse createCourse() {
        return new JavaCourse();
    }

    @Override
    public INote createNote() {
        return new JavaNote();
    }
}
```

```java
public class PythonCourseFactory implements ICourseFactory {
    @Override
    public ICourse createCourse() {
        return new PythonCourse();
    }

    @Override
    public INote createNote() {
        return new PythonNote();
    }
}
```

```java
public class AbstractFactoryTest {

    public static void main(String[] args) {
        ICourseFactory javaFactory = new JavaCourseFactory();
        ICourse javaCourse = javaFactory.createCourse();
        javaCourse.record();
        INote javaNote = javaFactory.createNote();
        javaNote.takeNote();

        ICourseFactory pythonFactory = new PythonCourseFactory();
        ICourse pythonCourse = pythonFactory.createCourse();
        pythonCourse.record();
        INote pythonNote = pythonFactory.createNote();
        pythonNote.takeNote();
        
    }
}
```



代码 UML 类图：

![abstract-factory](../img/dp/abstract-factory.png)



## 单例模式























